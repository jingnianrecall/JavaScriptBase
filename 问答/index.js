/**
 * 原型及原型链的理解

 * 1、什么是原型？
      每个构造函数有一个属性 prototype 指向原型对象（实例原型）。
      实例有一个属性__proto__ 指向原型对象（实例原型）。
      原型对象（实例原型） 构造函数.prototype 有一个属性constructor 指回构造函数。
      实例原型的属性 __proto__指向Object.prototype。（Object.prototype没有原型，查询到终点）
   2、什么是原型链？
      当读取实例的属性时，如果在实例中找不到，就会查找与对象关联的原型中的属性，
      还查不到，就去查原型的原型，一直找到顶层为止。依次查找的这一条链，就叫原型链。
 */

/**
 * 作用域的理解
 * 
 * JavaScript采用的是词法作用域（静态作用域）

 * 1、什么是作用域？
      作用域规定了如何查找变量，确定当前执行代码对变量的访问权限。
   2、var 提升问题，let const 块级作用域。
 */

/**
 * 执行上下文栈 ECS
 * 
 * 1、什么是ECS
 *    JS执行一段代码时，会进行 “准备工作” ，即创建执行上下文。(JS可执行代码分为全局、函数、eval代码 )
 *    执行上下文栈用于管理执行上下文。
 *    
 */


/**
 * 执行上下文
 * 
 * 1、什么是执行上下文？
 *    JavaScript执行一段可执行代码时会创建对应的执行上下文。
 *    每个执行上下文，有三个属性：
 *    * 变量对象（VO）
 *    * 作用域链（Scope chain）
 *    * this
 */

/**
 * 变量对象
 * 
 *   1、变量对象是与执行上下文相关的数据作用域，存储在上下文中定义的变量和函数声明。
 *      ** 全局上下文中的变量对象就是全局对象（Window）**
 *   2、函数上下文
 *      用活动对象（AO）来表示变量对象，进入到一个执行上下文中，这个变量对象才会被激活。
 *      被激活的变量对象就是活动对象，被激活才可以访问属性。
 *      通过函数的arguments属性初始化。
 * 
 *   3、变量对象总结
 *     1、全局上下文的变量对象初始化是全局对象。
 *     2、函数上下文的变量对象初始化只包括Arguments对象
 *     3、进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。
 *     4、代码执行阶段，会再次修改变量对象的属性值。
 * 
 *   注：不使用var声明变量，不会被存放在AO中。
 *       进行执行上下文时，首先处理函数声明，其次处理变量声明
 */


/**
 * 作用域链
 * 
 * 函数有一个内部属性[[scope]],函数创建时就会包含所有父变量对象，即[[scope]]就是所有父变量对象的层级链。
 * 
 * 函数执行时，进入函数上下文，创建VO/AO后，将活动对象添加到作用域的前端。
 * Scope = [AO].concat([[Scope]]);
 * 
 * 作用域链创建完毕
 */

/**
 * this
 * 
 */

/**
 * 执行上下文
 *  一段代码的执行过程：
 *  1、执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈。
 *  2、全局上下文初始化，VO Scope this。
 *  3、初始化的同时，当前执行函数被创建，保存作用域链到函数的内部属性[[scope]]。
 *  4、执行当前函数，创建函数执行上下文，函数执行上下文被压入执行上下文栈。
 *  5、当前函数执行上下文初始化：
 *      1、复制函数[[scope]]属性创建作用域链。
 *      2、用 arguments 创建活动对象。
 *      3、初始化活动对象，即加入形参、函数声明、变量声明。
 *      4、将活动对象压入当前函数作用域链顶端。
 *   同时内部函数被创建，保存作用域链到内部函数的内部属性[[scope]]
 *   6、执行内部函数，创建内部函数执行上下文，内部函数的执行上下文被压入执行上下文栈。
 *   7、内部函数的执行上下文初始化
 *      1、复制函数[[scope]]属性创建作用域链
 *      2、用arguments创建活动对象
 *      3、初始化活动对象，即加入形参、函数声明、变量声明
 *      4、将活动对象压入内部函数作用域链顶端
 *   8、内部函数执行，沿着作用域链查找scope值并返回
 *   9、内部函数执行完毕，内部函数上下文从执行上下文栈中弹出
 *   10、当前函数执行完毕，当前函数执行上下文从执行上下文栈中弹出。
 */

/**
 * 闭包
 * 
 * 1、什么是闭包？
 *    理论角度：在函数中可以访问自由变量，自由变量既不是函数参数也不是函数局部变量。
 *    实践角度：
 *      1、即使创建他的上下文已经销毁，他仍然存在（比如 内部函数从父函数返回）。
 *      2、在代码中引用了自由变量。
 * 
 *    父级函数上下文执行完成被销毁后，其内部函数的作用域链中依然保存着父级函数的作用域链。
 *    内部函数可以通过作用域链访问到已被销毁的父级函数的变量，从而实现了闭包
 *      
 *    var data = [];
 * 
 *    for (var i = 0; i < 3; i++) {
 *      data[i] = function () {
 *          console.log(i);
 *      }
 *    }
 * 
 *    var data = [];
 * 
 *    for (var i = 0; i < 3; i++) {
 *      data[i] = (function (i) {
 *          return function () {
 *              console.log(i);
 *          }
 *      })(i);
 *    }
 */

